<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>4. Performance and Security Analysis &mdash; SDZKP: A Zero-knowledge Proof using Subgroup Distance Problem 0.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=01f34227"></script>
        <script src="_static/doctools.js?v=9a2dae69"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="5. Code Documentation" href="code.html" />
    <link rel="prev" title="3. SDZKP Specification" href="requirements.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            SDZKP: A Zero-knowledge Proof using Subgroup Distance Problem
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="sdzkp.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="sdzkp.html#installation">2. Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="requirements.html">3. SDZKP Specification</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">4. Performance and Security Analysis</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#setup-related-tasks">4.1. Setup Related Tasks</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#max2sat-instance-generation">4.1.1. Max2SAT Instance Generation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#subgroup-distance-problem-generation">4.1.2. Subgroup Distance Problem Generation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#prover-related-tasks">4.2. Prover Related Tasks</a></li>
<li class="toctree-l2"><a class="reference internal" href="#verifier-related-tasks">4.3. Verifier Related Tasks</a></li>
<li class="toctree-l2"><a class="reference internal" href="#security-related-validation">4.4. Security Related Validation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#completeness-validation">4.4.1. Completeness Validation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#soundness-validation">4.4.2. Soundness Validation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="code.html">5. Code Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="bibliography.html">6. References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">SDZKP: A Zero-knowledge Proof using Subgroup Distance Problem</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active"><span class="section-number">4. </span>Performance and Security Analysis</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="performance-and-security-analysis">
<h1><span class="section-number">4. </span>Performance and Security Analysis<a class="headerlink" href="#performance-and-security-analysis" title="Link to this heading"></a></h1>
<p>We provide detailed performance and security analysis in this section. All the tests presented in the
sequel are run on an iMac with 3,2 GHz 8-Core Intel Xeon W with 32 GB 2666 MHz DDR4 RAM. The results are the
averages of 100 runs.</p>
<section id="setup-related-tasks">
<h2><span class="section-number">4.1. </span>Setup Related Tasks<a class="headerlink" href="#setup-related-tasks" title="Link to this heading"></a></h2>
<p>In this section, we present the performance evaluation results for NP problem instance generation. The subgroup distance problem (SGD)
relies on Max2SAT instances. We firstly create a Max2SAT instance using Motoki’s algorithm <span id="id1">[<a class="reference internal" href="bibliography.html#id4" title="Mistuo Motoki. Test instance generation for max 2sat. In Principles and Practice of Constraint Programming-CP 2005: 11th International Conference, CP 2005, Sitges, Spain, October 1-5, 2005. Proceedings 11, 787–791. Springer, 2005.">Mot05</a>]</span>. Then, we convert the Max2SAT instance to SGD instance
using our novel approach.</p>
<section id="max2sat-instance-generation">
<h3><span class="section-number">4.1.1. </span>Max2SAT Instance Generation<a class="headerlink" href="#max2sat-instance-generation" title="Link to this heading"></a></h3>
<p>For Max2SAT instance generation we use Motoki’s approach as presented in <span id="id2">[<a class="reference internal" href="bibliography.html#id4" title="Mistuo Motoki. Test instance generation for max 2sat. In Principles and Practice of Constraint Programming-CP 2005: 11th International Conference, CP 2005, Sitges, Spain, October 1-5, 2005. Proceedings 11, 787–791. Springer, 2005.">Mot05</a>]</span> that proposes a randomized algorithm to generate test instances for the MAX 2SAT problem. The algorithm ensures that the generated instances have exactly one unsatisfied clause at the optimal solution, with a probability of 1. The author proves that the number of clauses in the generated instances is, with high probability, greater than the number of variables, aligning with known thresholds for unsatisfiability in random 2CNF formulas.</p>
<p>MAX 2SAT is a well-known NP-complete combinatorial optimization problem, where the goal is to find a truth assignment that maximizes the number of satisfied clauses in a 2CNF formula. To evaluate the performance of approximation algorithms for MAX 2SAT, both theoretical analysis and empirical studies are used. However, empirical studies require test instances with known optimal solutions. The paper addresses the challenge of generating such instances randomly.</p>
<p>The proposed algorithm generates an instance by first selecting a truth assignment <cite>t</cite> as the optimal solution. It then adds one randomly chosen clause that is unsatisfied by <cite>t</cite> and continues to add clauses satisfied by <cite>t</cite> until the formula becomes unsatisfiable. The algorithm ensures that the generated instance has a fixed optimal value, specifically one unsatisfied clause.</p>
<p>The paper analyzes the number of clauses added until the algorithm halts. It demonstrates that the threshold for the number of clauses is the number of variables, meaning that the algorithm is likely to stop only when the number of clauses exceeds the number of variables. This result coincides with the threshold for unsatisfiability in 2CNF formulas. The paper also provides a detailed mathematical analysis, proving that the algorithm works with high probability.</p>
<p>The paper presents a significant contribution to the generation of test instances for MAX 2SAT, providing a useful tool for evaluating approximation algorithms. The approach is mathematically rigorous and ensures that the generated instances meet the desired criteria with high probability.</p>
<figure class="align-default" id="id4">
<span id="fig-max2sat-benchmark-with-ci"></span><img alt="The execution times with 95% confidence for Max2SAT problem instance generation." src="_images/max2sat_benchmark_with_ci.png" />
<figcaption>
<p><span class="caption-number">Fig. 4.1 </span><span class="caption-text">The execution times with 95% confidence for Max2SAT problem instance generation.</span><a class="headerlink" href="#id4" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><a class="reference internal" href="#fig-max2sat-benchmark-with-ci"><span class="std std-numref">Fig. 4.1</span></a> illustrates the execution time required to generate a <cite>Max2SAT</cite> instance as a function
of the number of variables. The data points are plotted with error bars that represent the 95% confidence intervals, providing
a visual indication of the variability in the measurements. As the number of variables increases, the execution time also
increases. This is consistent with the expected behavior as more complex instances with larger numbers of variables require
more computational resources to generate. The error bars show that the variability in execution time also increases with
the number of variables, which is typical as the system may experience greater fluctuations in processing time due to
the increased complexity of the problem instances. Overall, the figure effectively conveys the relationship between
the number of variables in a <cite>Max2SAT</cite> instance and the time required to generate it, highlighting both the trend and
the associated uncertainties.</p>
</section>
<section id="subgroup-distance-problem-generation">
<h3><span class="section-number">4.1.2. </span>Subgroup Distance Problem Generation<a class="headerlink" href="#subgroup-distance-problem-generation" title="Link to this heading"></a></h3>
<p><a class="reference internal" href="#fig-sgd-benchmark-with-ci"><span class="std std-numref">Fig. 4.2</span></a>  illustrates the execution time required to generate an instance of the Subgroup
Distance (SGD) problem as a function of the number of generators which is two times the number of variables in the employed Max2SAT instance. The plot includes error bars representing a 95%
confidence interval, providing insight into the variability of the timing measurements. As the number of generators
increases, the execution time rises significantly, showing a clear upward trend that appears to be nonlinear. This
indicates that the complexity of generating an SGD instance grows rapidly with the number of generators. The increasing
size of the confidence intervals for larger numbers of generators suggests that the variability in execution time
also increases with the complexity of the problem. This could be due to factors such as increased computational
demands and system resource allocation. Overall, the figure effectively conveys the relationship between the
number of generators and the time required to generate an SGD instance, while also highlighting the increasing
uncertainty in execution time as the problem size grows.</p>
<figure class="align-default" id="id5">
<span id="fig-sgd-benchmark-with-ci"></span><img alt="The execution times with 95% confidence for SGD problem instance generation." src="_images/sgd_benchmark_with_ci.png" />
<figcaption>
<p><span class="caption-number">Fig. 4.2 </span><span class="caption-text">The execution times with 95% confidence for SGD problem instance generation.</span><a class="headerlink" href="#id5" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
</section>
<section id="prover-related-tasks">
<h2><span class="section-number">4.2. </span>Prover Related Tasks<a class="headerlink" href="#prover-related-tasks" title="Link to this heading"></a></h2>
<p>In SDZKP, the main computational load on the prover is the commitment generation. The response generation is O(1) since the computation effort for response
generation is mainly handled during commitment generation. That is why, we present the commitment generation execution times here. <a class="reference internal" href="#fig-prover-commitment-with-ci"><span class="std std-numref">Fig. 4.3</span></a>  shows
execution times for commitment generation by the prover as the number of generators in the SGD problem changes. The commitment generation algorithm linearly
depends on the number of generators, therefore the execution time is a linear function of the number of generators. For an acceptable security level,
for instance 128 bits of entropy, the commitment generation takes around 1 second.</p>
<figure class="align-default" id="id6">
<span id="fig-prover-commitment-with-ci"></span><img alt="The execution times with 95% confidence for commitment generation by the prover." src="_images/prover_commitment_with_ci.png" />
<figcaption>
<p><span class="caption-number">Fig. 4.3 </span><span class="caption-text">The execution times with 95% confidence for commitment generation by the prover.</span><a class="headerlink" href="#id6" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="verifier-related-tasks">
<h2><span class="section-number">4.3. </span>Verifier Related Tasks<a class="headerlink" href="#verifier-related-tasks" title="Link to this heading"></a></h2>
<p><a class="reference internal" href="#fig-verifier-verification-with-ci"><span class="std std-numref">Fig. 4.4</span></a> presents a line plot showing the relationship between the number of generators and the verification
time by the verifier, including a 95% confidence interval. The x-axis represents the number of generators,
ranging from around 10 to 120, while the y-axis measures the execution time in seconds, with values ranging
from 0.00 to approximately 0.35 seconds. The plot reveals that the verification time remains relatively low
and stable as the number of generators increases from 10 to around 90. The confidence intervals are visible as error bars,
indicating greater variability in the verification time. In this experiment, we randomly select a challenge value from the
set  {0,1,2}. All the cases, contain code for honest prover; that is, the verification process has to provide True for all challenges.
The spikes may be the result of discrepencies in random challenge selection process. All in all, the verification process takes almost a third
of the commiment generation time. We can conclude that verifier’s computation load is considerably lower than that of the prover.</p>
<figure class="align-default" id="id7">
<span id="fig-verifier-verification-with-ci"></span><img alt="The execution times with 95% confidence for commitment generation by the prover." src="_images/verifier_verification_with_ci.png" />
<figcaption>
<p><span class="caption-number">Fig. 4.4 </span><span class="caption-text">The execution times with 95% confidence for commitment generation by the prover.</span><a class="headerlink" href="#id7" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="security-related-validation">
<h2><span class="section-number">4.4. </span>Security Related Validation<a class="headerlink" href="#security-related-validation" title="Link to this heading"></a></h2>
<p>A zero-knowledge protocol has to satisfy completeness, soundness and zero-knowledge properties. In this section, we
present the completeness and soundness validations for SDZKP. Please refer to <span id="id3">[<a class="reference internal" href="bibliography.html#id2" title="Cansu Betin Onur. A zero-knowledge proof of knowledge for subgroup distance problem. 2024. URL: https://arxiv.org/abs/2408.00395, arXiv:2408.00395.">Onu24</a>]</span>
for the theoretic proof for zero-knowledge property.</p>
<section id="completeness-validation">
<h3><span class="section-number">4.4.1. </span>Completeness Validation<a class="headerlink" href="#completeness-validation" title="Link to this heading"></a></h3>
<p>The benchmark code for validating the completeness of the SDZKP is designed to abort in any run if
any round producess a verification failure (returns False). The code runs until completion proving
that none of the rounds are False if the prover is honest and has the solution to the subgroup
distance problem.</p>
<figure class="align-default" id="id8">
<span id="fig-completeness-with-ci"></span><img alt="The execution times with 95% confidence for completeness validation." src="_images/completeness_with_ci.png" />
<figcaption>
<p><span class="caption-number">Fig. 4.5 </span><span class="caption-text">The execution times with 95% confidence for completeness validation.</span><a class="headerlink" href="#id8" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><a class="reference internal" href="#fig-completeness-with-ci"><span class="std std-numref">Fig. 4.5</span></a>  depicts the execution time required for an honest prover to demonstrate completeness
in a proof system, plotted against the number of generators. The plot shows a clear upward trend,
indicating that as the number of generators increases, the execution time also increases significantly.
The relationship between the number of generators and execution time appears to be approximately
linear, as suggested by the straight-line pattern of the data points. The error bars, representing
a 95% confidence interval, provide an indication of the variability in the measurements.
The confidence intervals are relatively small, particularly for lower numbers of generators,
suggesting consistent execution times in those cases. However, as the number of generators
increases, the confidence intervals widen slightly, indicating a growing uncertainty or variability
in execution time. This could be attributed to the increasing computational complexity as the
problem scales.</p>
</section>
<section id="soundness-validation">
<h3><span class="section-number">4.4.2. </span>Soundness Validation<a class="headerlink" href="#soundness-validation" title="Link to this heading"></a></h3>
<p>In this scenario, the prover is dishonest, it knows the public parameters of the SGD problem.
The dishonest prover creates a random solution; that is, it selects a subset of generators that produces a subgroup
element randomly. Then, he tries to convince the verifier that it knows the solution. In any protocol run,
if the verifier returns a False (not verified) result in any round, then the protocol run is assumed to
fail, otherwise the protocol run is counted as verified. The benchmark code for validating the soundness of the
SDZKP is designed to find the ratio of  verified (returned True) protocol runs to the total number of
protocol runs that we refer to as the cheating probability since the prover is dishonest.  <a class="reference internal" href="#fig-soundness-cheating-prob"><span class="std std-numref">Fig. 4.6</span></a>
shows the cheating probability for 1000 simulation runs where the number of generators is set to 8 in SGD problem. As expected,
when the total number of rounds is 1 in a protocol run, then the cheating probability is <span class="math notranslate nohighlight">\(\frac{2}{3}\)</span>. As the number of
rounds increases, the cheating probability decreases exponentially with probability <span class="math notranslate nohighlight">\((\frac{2}{3})^k\)</span> where k is the
total number of rounds in a protocol run. This trend is clearly visible in <a class="reference internal" href="#fig-soundness-cheating-prob"><span class="std std-numref">Fig. 4.6</span></a> . Approximately,
after 16 rounds, the cheating probability becomes less then 0.001.</p>
<figure class="align-default" id="id9">
<span id="fig-soundness-cheating-prob"></span><img alt="The cheating probability for soundness validation." src="_images/soundness_cheating_prob.png" />
<figcaption>
<p><span class="caption-number">Fig. 4.6 </span><span class="caption-text">The cheating probability for soundness validation.</span><a class="headerlink" href="#id9" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><a class="reference internal" href="#fig-soundness-executiontime-with-ci"><span class="std std-numref">Fig. 4.7</span></a> shows the execution times of the protocol run as the number of rounds in a run increases.
As expected, a larger number of rounds in a run requires a larger amount of time to accomplish the verification process.</p>
<figure class="align-default" id="id10">
<span id="fig-soundness-executiontime-with-ci"></span><img alt="The execution times with 95% confidence for soundness validation." src="_images/soundness_executiontime_with_ci.png" />
<figcaption>
<p><span class="caption-number">Fig. 4.7 </span><span class="caption-text">The execution times with 95% confidence for soundness validation.</span><a class="headerlink" href="#id10" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="requirements.html" class="btn btn-neutral float-left" title="3. SDZKP Specification" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="code.html" class="btn btn-neutral float-right" title="5. Code Documentation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Cansu Betin Onur.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>